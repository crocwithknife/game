<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Character Platformer Game - Robust++!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // Configure Tailwind CSS
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    boxShadow: {
                        'glow': '0 0 15px 5px rgba(99, 102, 241, 0.5)',
                    },
                    colors: {
                        'placeholder-bg': '#a0aec0', 'placeholder-text': '#ffffff', 'game-bg': '#f0f9ff',
                        'ground': '#e5e7eb', 'platform': '#a78bfa', 'platform-moving': '#c4b5fd',
                        'lava': '#fb923c',
                        'obstacle': '#ef4444', 'obstacle-short': '#f97316', 'obstacle-flying': '#a3e635',
                        'projectile': '#fca5a5',
                        'collectible': '#facc15', 'powerup-shield': '#60a5fa', 'powerup-multiplier': '#f472b6',
                        'particle-jump': '#cbd5e1', 'particle-double-jump': '#fde047',
                        'particle-collect': '#fde047', 'particle-powerup-shield': '#93c5fd', 'particle-powerup-multiplier': '#fda4af',
                        'particle-dash': '#ffffff', 'particle-gameover': '#f87171',
                        'score-text': '#374151', 'score-text-multi': '#ec4899',
                        'game-over-text': '#dc2626', 'page-bg': '#e5e7eb', 'text-main': '#1f2937',
                        'text-light': '#4b5563', 'button-text': '#ffffff',
                        'bg-layer-1': '#e0f2fe', 'bg-layer-2': '#d1d5db', 'bg-layer-3': '#9ca3af',
                        'highscore-text': '#6b7280',
                        'touch-btn-bg': 'rgba(107, 114, 128, 0.6)',
                        'touch-btn-active-bg': 'rgba(75, 85, 99, 0.8)',
                    }
                }
            }
        }
    </script>
    <style>
        /* Basic styling */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; /* Prevent body scroll */ }
        body { font-family: 'Inter', sans-serif; background-color: theme('colors.page-bg'); color: theme('colors.text-main'); display: flex; justify-content: center; align-items: center; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
        .character-card.selected { border-color: #6366f1; box-shadow: 0 0 15px 5px rgba(99, 102, 241, 0.5); transform: scale(1.05); }
        .character-card, button:not(.touch-button) { transition: all 0.2s ease-in-out; }
        .character-card img { display: block; margin-left: auto; margin-right: auto; margin-bottom: 0.5rem; max-width: 100%; height: auto; aspect-ratio: 1 / 1; object-fit: contain; background-color: #e5e7eb; border-radius: 0.25rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:hover:not(:disabled):not(.touch-button) { filter: brightness(1.1); }
        .hidden { display: none; }

        /* Responsive Container Style */
        .main-container {
            background-color: theme('colors.white'); border-radius: 0.5rem; box-shadow: theme('boxShadow.xl');
            padding: 1.5rem; text-align: center;
            width: 95%; max-width: 600px; /* Adjusted max-width for selection */
            max-height: 95vh;
            position: relative; color: theme('colors.text-main');
            display: flex; flex-direction: column; justify-content: center;
        }
         /* Game area container takes more space */
        #game-area-container {
             padding: 1rem;
             width: 95%; /* Take most of viewport width */
             max-width: 900px; /* Max width on large screens */
             height: 90vh; /* Take most of viewport height */
             max-height: 700px; /* Max height */
        }
        /* Canvas style - Use CSS to scale visually */
        #gameCanvas {
            background-color: theme('colors.game-bg'); border-radius: 0.5rem; border: 1px solid theme('colors.gray.300');
            display: block;
            max-width: 100%; /* Ensure canvas doesn't overflow container width */
            max-height: calc(100% - 4rem); /* Ensure canvas doesn't overflow container height (leaving space for buttons) */
            margin: 0 auto 1rem auto; /* Center horizontally */
            position: relative;
            background-image: linear-gradient(theme('colors.bg-layer-3') 1px, transparent 1px), radial-gradient(theme('colors.bg-layer-2') 1px, transparent 1px), linear-gradient(to bottom, theme('colors.bg-layer-1') 1px, transparent 1px);
            background-size: 10px 10px, 15px 15px, 100% 25px;
            background-position: 0 0, 0 0, 0 0;
            background-repeat: repeat, repeat, repeat-x;
            image-rendering: pixelated;
            /* width/height styles set by JS */
            object-fit: contain; /* Let browser handle scaling within bounds */
        }

        /* Score display */
        #score-display { position: absolute; top: 0.5rem; left: 0.5rem; /* Adjusted position */ font-size: 1.2rem; /* Slightly smaller */ font-weight: bold; color: theme('colors.score-text'); z-index: 10; transition: color 0.3s ease; background: rgba(255,255,255,0.7); padding: 0.2rem 0.5rem; border-radius: 0.25rem; }
        #score-display.multiplier-active { color: theme('colors.score-text-multi'); }
        /* High Score display */
        #high-score-display { position: absolute; top: 0.5rem; right: 0.5rem; /* Adjusted position */ font-size: 0.9rem; /* Slightly smaller */ font-weight: normal; color: theme('colors.highscore-text'); z-index: 10; background: rgba(255,255,255,0.7); padding: 0.2rem 0.5rem; border-radius: 0.25rem;}
        /* Game Over message */
        #game-over-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; /* Adjusted size */ font-weight: bold; color: theme('colors.game-over-text'); text-shadow: 1px 1px 2px rgba(0,0,0,0.2); z-index: 20; text-align: center; white-space: pre-wrap; background: rgba(255, 255, 255, 0.8); padding: 1rem; border-radius: 0.5rem; }
        #selected-character-info { color: theme('colors.text-light'); }

        /* Touch Controls Styling */
        #touch-controls {
            position: fixed; bottom: 15px; left: 0; right: 0; display: flex; justify-content: space-between; padding: 0 15px; z-index: 50; pointer-events: none;
        }
        .touch-button {
            background-color: theme('colors.touch-btn-bg'); color: white; border: none; border-radius: 50%; width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 1.8rem; font-weight: bold; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2); pointer-events: auto; -webkit-tap-highlight-color: transparent; transition: background-color 0.1s ease, transform 0.1s ease;
        }
        .touch-button:active { background-color: theme('colors.touch-btn-active-bg'); transform: scale(0.95); }
        #touch-controls > div { display: flex; gap: 15px; }

        /* Simple Landscape adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .touch-button { width: 50px; height: 50px; font-size: 1.5rem; }
            #touch-controls { bottom: 10px; padding: 0 10px; }
            .main-container { padding: 0.5rem; } /* Reduce padding */
            #game-area-container { height: 95vh; } /* Take more height */
            #score-display { top: 0.5rem; left: 0.5rem; font-size: 1rem; }
            #high-score-display { top: 0.5rem; right: 0.5rem; font-size: 0.8rem; }
            #gameCanvas { margin-bottom: 0.5rem; max-height: calc(100% - 3rem); } /* Adjust max-height */
        }

    </style>
</head>
<body class="bg-page-bg text-text-main">

    <div id="character-select-container" class="main-container">
         <h1 class="text-4xl font-bold mb-8 text-indigo-600">Choose Your Character</h1>
        <div id="character-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-6 mb-8">
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="stabby" data-character-name="Stabby" data-character-img="https://i.imgur.com/hOAkq4W.png">
                 <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/hOAkq4W.png" alt="Stabby" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';">
                 <span class="font-semibold text-text-main">Stabby</span>
             </div>
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="canuck" data-character-name="Canuck" data-character-img="https://i.imgur.com/mcrXKUb.png">
                 <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/mcrXKUb.png" alt="Canuck" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';">
                 <span class="font-semibold text-text-main">Canuck</span>
             </div>
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="croakey" data-character-name="Croakey" data-character-img="https://i.imgur.com/kfBBO7r.png">
                 <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/kfBBO7r.png" alt="Croakey" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';">
                 <span class="font-semibold text-text-main">Croakey</span>
             </div>
        </div>
        <div id="selected-character-info" class="mb-8 h-8 text-lg"> Select a character to begin! </div>
        <button id="start-game-btn" class="bg-indigo-600 hover:bg-indigo-700 text-button-text font-bold py-3 px-8 rounded-lg text-xl shadow-md" disabled> Start Game </button>
    </div>

    <div id="game-area-container" class="main-container hidden">
         <div id="score-display">Score: 0</div>
         <div id="high-score-display">High Score: 0</div>
         <div id="game-over-message" class="hidden">Game Over!</div>
         <canvas id="gameCanvas" width="550" height="350" class="mx-auto mb-4"></canvas>
         <div class="flex justify-center space-x-4 mt-auto"> <button id="back-to-select-btn" class="bg-gray-500 hover:bg-gray-600 text-button-text font-bold py-2 px-6 rounded-lg shadow-md"> Back to Select </button>
            <button id="restart-btn" class="bg-green-600 hover:bg-green-700 text-button-text font-bold py-2 px-6 rounded-lg shadow-md hidden"> Restart </button>
         </div>

         <div id="touch-controls" class="hidden"> <div> <button id="touch-left" class="touch-button">&#x2190;</button> <button id="touch-right" class="touch-button">&#x2192;</button> </div>
             <div> <button id="touch-dash" class="touch-button">&#x26A1;</button> <button id="touch-jump" class="touch-button">&#x2191;</button> </div>
         </div>
    </div>

    <script>
        // --- DOM Elements ---
        const characterSelectContainer = document.getElementById('character-select-container');
        const gameAreaContainer = document.getElementById('game-area-container');
        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const gameOverMessage = document.getElementById('game-over-message');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startGameBtn = document.getElementById('start-game-btn');
        const backToSelectBtn = document.getElementById('back-to-select-btn');
        const restartBtn = document.getElementById('restart-btn');
        const characterCards = document.querySelectorAll('.character-card');
        const selectedCharacterInfo = document.getElementById('selected-character-info');
        const touchControlsContainer = document.getElementById('touch-controls');
        const touchLeftBtn = document.getElementById('touch-left');
        const touchRightBtn = document.getElementById('touch-right');
        const touchJumpBtn = document.getElementById('touch-jump');
        const touchDashBtn = document.getElementById('touch-dash');

        // --- Game Constants ---
        const BASE_CANVAS_WIDTH = 550; const BASE_CANVAS_HEIGHT = 350; const TARGET_FPS = 60; const GRAVITY = 0.5 * TARGET_FPS * TARGET_FPS; const JUMP_STRENGTH = 10 * TARGET_FPS; const MAX_JUMPS = 2; const GROUND_Y = BASE_CANVAS_HEIGHT - 25; const LAVA_HEIGHT = 10; const PLAYER_WIDTH = 40; const PLAYER_HEIGHT = 40; const PLAYER_SPEED = 4 * TARGET_FPS; const DASH_KEY = 'Shift'; const DASH_DURATION_SECONDS = 10 / TARGET_FPS; const DASH_SPEED_MULTIPLIER = 3; const DASH_COOLDOWN_SECONDS = 60 / TARGET_FPS; const DASH_INVINCIBILITY = true; const OBSTACLE_WIDTH = 25; const OBSTACLE_HEIGHT_TALL = 40; const OBSTACLE_HEIGHT_SHORT = 20; const OBSTACLE_FLYING_SIZE = 30; const BASE_OBSTACLE_SPEED = 3 * TARGET_FPS; const MAX_OBSTACLE_SPEED = 7 * TARGET_FPS; const BASE_SPAWN_INTERVAL_SECONDS = 100 / TARGET_FPS; const MIN_SPAWN_INTERVAL_SECONDS = 45 / TARGET_FPS; const SCORE_SPEED_INCREASE_THRESHOLD = 300; const SCORE_INTERVAL_DECREASE_THRESHOLD = 600; const COLLECTIBLE_SIZE = 15; const COLLECTIBLE_VALUE = 50; const COLLECTIBLE_SPAWN_INTERVAL_SECONDS = 150 / TARGET_FPS; const POWERUP_SIZE = 20; const POWERUP_SPAWN_INTERVAL_SECONDS = 650 / TARGET_FPS; const POWERUP_SHIELD_DURATION_SECONDS = 300 / TARGET_FPS; const MULTIPLIER_DURATION_SECONDS = 400 / TARGET_FPS; const SCORE_MULTIPLIER_VALUE = 3; const EMOJI_OBSTACLE_TALL = '🧱'; const EMOJI_OBSTACLE_SHORT = '🪨'; const EMOJI_OBSTACLE_FLYING = '👻'; const EMOJI_COLLECTIBLE = '⭐'; const EMOJI_POWERUP_SHIELD = '🛡️'; const EMOJI_POWERUP_MULTIPLIER = '✨'; const STORAGE_KEY = 'blockyGameHighScore'; const PARTICLE_GRAVITY = 0.05 * TARGET_FPS * TARGET_FPS; const PARTICLE_MIN_LIFE_SECONDS = 15 / TARGET_FPS; const PARTICLE_MAX_LIFE_SECONDS = 35 / TARGET_FPS; const MAX_PARTICLES = 200; const SCREEN_SHAKE_DURATION_SECONDS = 15 / TARGET_FPS; const SCREEN_SHAKE_MAGNITUDE = 4; const PLATFORM_HEIGHT = 15; const PLATFORM_MIN_WIDTH = 80; const PLATFORM_MAX_WIDTH = 150; const PLATFORM_SPAWN_CHANCE = 0.2; const PLATFORM_MOVE_SPEED = 0.8 * TARGET_FPS; const COLLISION_X_BUFFER = 100; const PROJECTILE_WIDTH = 5; const PROJECTILE_HEIGHT = 10; const PROJECTILE_SPEED = 3 * TARGET_FPS; const FLYING_SHOOT_COOLDOWN_SECONDS = 120 / TARGET_FPS; const PATTERN_SPAWN_CHANCE = 0.1; const PATTERN_MIN_INTERVAL_SECONDS = 180 / TARGET_FPS;

        // --- Game State ---
        let selectedCharacter = null; let player = {}; let keys = {}; let obstacles = []; let collectibles = []; let powerups = []; let particles = []; let particlePool = []; let platforms = []; let projectiles = []; let score = 0; let highScore = 0; let isGameOver = false; let animationFrameId = null; let currentObstacleSpeed = BASE_OBSTACLE_SPEED; let currentSpawnIntervalSeconds = BASE_SPAWN_INTERVAL_SECONDS; let timeSinceLastObstacleSpawn = 0; let timeSinceLastCollectibleSpawn = 0; let timeSinceLastPowerupSpawn = 0; let timeSinceLastPlatform = 0; let timeSinceLastPattern = PATTERN_MIN_INTERVAL_SECONDS; let backgroundOffset1 = 0; let backgroundOffset2 = 0; let backgroundOffset3 = 0; let screenShakeActive = false; let screenShakeTimer = 0; let lastTimestamp = 0; let resizeTimeout;

        // --- Audio State & Synths ---
        let audioInitialized = false; let jumpSynth = null; let collectSynth = null; let gameOverSynth = null; let powerupShieldSynth = null; let powerupMultiplierSynth = null; let projectileShootSynth = null; let dashSynth = null; let bgMusicSynth = null; let musicLoop = null;
        if (typeof Tone !== 'undefined') { try { jumpSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination(); collectSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination(); gameOverSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 } }).toDestination(); powerupShieldSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(); powerupMultiplierSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 } }).toDestination(); projectileShootSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }, volume: -15 }).toDestination(); dashSynth = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }, volume: -10 }).toDestination(); bgMusicSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }, volume: -18 }).toDestination(); const musicSequence = ["C3", ["E3", "G3"], "C4", ["E3", "G3"]]; let musicStep = 0; musicLoop = new Tone.Loop(time => { let note = musicSequence[musicStep % musicSequence.length]; bgMusicSynth.triggerAttackRelease(note, "8n", time); musicStep++; }, "4n"); } catch (e) { console.error("Error creating Tone.js synths:", e); } } else { console.warn("Tone.js not loaded, sound effects disabled."); }

        // --- Load High Score ---
        try { const storedHighScore = localStorage.getItem(STORAGE_KEY); if (storedHighScore) { highScore = parseInt(storedHighScore, 10) || 0; } } catch (e) { console.error("Could not load high score from localStorage:", e); highScore = 0; }

        // --- Character Selection Logic ---
        characterCards.forEach(card => { card.addEventListener('click', () => { characterCards.forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedCharacter = { id: card.dataset.characterId, name: card.dataset.characterName, imgSrc: card.dataset.characterImg }; selectedCharacterInfo.textContent = `Selected: ${selectedCharacter.name}`; startGameBtn.disabled = false; }); });

        // --- Screen Transition Logic ---
        startGameBtn.addEventListener('click', async () => { if (selectedCharacter) { characterSelectContainer.classList.add('hidden'); gameAreaContainer.classList.remove('hidden'); touchControlsContainer.classList.remove('hidden'); resizeCanvas(); initGame(); if (typeof Tone !== 'undefined' && !audioInitialized && Tone.context.state !== 'running') { try { await Tone.start(); audioInitialized = true; console.log('Audio context started successfully.'); if (musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music started.'); } } catch (e) { console.error("Error starting audio context:", e); } } else if (audioInitialized && musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music started (context was already running).'); } } });
        function stopMusic() { if (musicLoop && Tone.Transport.state === 'started') { musicLoop.stop(0); Tone.Transport.stop(); Tone.Transport.cancel(); musicStep = 0; console.log('Background music stopped.'); } }
        function goBackToSelect() { stopMusic(); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; lastTimestamp = 0; removeInputListeners(); window.removeEventListener('resize', handleResize); gameAreaContainer.classList.add('hidden'); touchControlsContainer.classList.add('hidden'); characterSelectContainer.classList.remove('hidden'); characterCards.forEach(c => c.classList.remove('selected')); startGameBtn.disabled = true; selectedCharacterInfo.textContent = 'Select a character to begin!'; selectedCharacter = null; restartBtn.classList.add('hidden'); gameOverMessage.classList.add('hidden'); }
        backToSelectBtn.addEventListener('click', goBackToSelect);
        restartBtn.addEventListener('click', () => { stopMusic(); initGame(); if (audioInitialized && musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music restarted.'); } });

        // --- Game Initialization ---
        function initGame() {
             isGameOver = false; score = 0; obstacles = []; collectibles = []; powerups = []; particles = []; platforms = []; projectiles = []; keys = {}; currentObstacleSpeed = BASE_OBSTACLE_SPEED; currentSpawnIntervalSeconds = BASE_SPAWN_INTERVAL_SECONDS; timeSinceLastObstacleSpawn = 0; timeSinceLastCollectibleSpawn = 0; timeSinceLastPowerupSpawn = 0; timeSinceLastPlatform = PATTERN_MIN_INTERVAL_SECONDS; timeSinceLastPattern = PATTERN_MIN_INTERVAL_SECONDS; backgroundOffset1 = 0; backgroundOffset2 = 0; backgroundOffset3 = 0; screenShakeActive = false; screenShakeTimer = 0; lastTimestamp = 0;
             player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT - 150, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, speed: PLAYER_SPEED, dx: 0, dy: 0, gravity: GRAVITY, jumpStrength: JUMP_STRENGTH, isOnGround: false, wasOnGround: false, jumpsRemaining: MAX_JUMPS, image: null, isPlaceholder: false, isInvincible: false, invincibilityTimer: 0, scoreMultiplier: 1, scoreMultiplierTimer: 0, landedOnPlatform: null, isDashing: false, dashTimer: 0, dashCooldownTimer: 0, dashDirection: 1 };
             scoreDisplay.textContent = `Score: 0`; scoreDisplay.classList.remove('multiplier-active'); highScoreDisplay.textContent = `High Score: ${highScore}`; gameOverMessage.classList.add('hidden'); restartBtn.classList.add('hidden'); backToSelectBtn.disabled = false; canvas.style.backgroundPositionX = '0px, 0px, 0px'; particlePool.forEach(p => p.active = false); particles = [];
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
             if (selectedCharacter?.imgSrc && selectedCharacter.imgSrc !== 'placeholder') {
                 player.image = new Image();
                 player.image.onload = () => { startGameSystems(); };
                 player.image.onerror = (e) => { console.error("INITGAME: Failed image load:", selectedCharacter.imgSrc, e); player.isPlaceholder = true; startGameSystems(); }
                 player.image.src = selectedCharacter.imgSrc;
             } else {
                 player.isPlaceholder = true;
                 startGameSystems();
             }
        }

        // --- Start Game Systems ---
        function startGameSystems() {
             addInputListeners();
             window.addEventListener('resize', handleResize);
             cancelAnimationFrame(animationFrameId); animationFrameId = null;
             lastTimestamp = performance.now();
             console.log("Requesting first animation frame...");
             animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Canvas Resizing ---
        function resizeCanvas() {
            const container = gameAreaContainer;
            // Use container's current dimensions as max available space
            // Subtract approximate space needed for buttons below canvas
            const availableWidth = container.clientWidth;
            const availableHeight = container.clientHeight - (restartBtn.offsetHeight > 0 ? restartBtn.offsetHeight + 30 : 80); // Approx height for buttons + margin

            if (availableWidth <= 0 || availableHeight <= 0) return; // Don't resize if container not visible

            const aspectRatio = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT;

            // Calculate scale based on fitting within available space
            const scale = Math.min(availableWidth / BASE_CANVAS_WIDTH, availableHeight / BASE_CANVAS_HEIGHT);

            // Calculate new dimensions based on scale
            let newWidth = BASE_CANVAS_WIDTH * scale;
            let newHeight = BASE_CANVAS_HEIGHT * scale;

            // Apply the style dimensions
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;

            console.log(`Resized canvas style to: ${newWidth.toFixed(0)}x${newHeight.toFixed(0)}`);
        }
        function handleResize() { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeCanvas, 100); }


        // --- Particle Handling ---
        function spawnParticles(count, x, y, color, speedRange, lifeRangeSeconds, initialVyBias = 0, initialVxBias = 0) { let spawnedCount = 0; const lifeMin = lifeRangeSeconds[0]; const lifeMax = lifeRangeSeconds[1]; for (let i = 0; i < particlePool.length && spawnedCount < count; i++) { if (!particlePool[i].active) { const p = particlePool[i]; p.x = x; p.y = y; const angle = Math.random() * Math.PI * 2; const speed = (Math.random() * speedRange + 0.5); p.vx = Math.cos(angle) * speed + initialVxBias; p.vy = Math.sin(angle) * speed + initialVyBias; p.size = Math.random() * 2.5 + 1.5; p.color = color; p.life = Math.random() * (lifeMax - lifeMin) + lifeMin; p.initialLife = lifeMax; p.active = true; if (!particles.includes(p)) { particles.push(p); } spawnedCount++; } } for (let i = spawnedCount; i < count && particlePool.length < MAX_PARTICLES; i++) { const angle = Math.random() * Math.PI * 2; const speed = (Math.random() * speedRange + 0.5); const p = { x: x, y: y, vx: Math.cos(angle) * speed + initialVxBias, vy: Math.sin(angle) * speed + initialVyBias, size: Math.random() * 2.5 + 1.5, color: color, life: Math.random() * (lifeMax - lifeMin) + lifeMin, initialLife: lifeMax, active: true }; particles.push(p); particlePool.push(p); } }
        function updateParticles(deltaTime) { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx * deltaTime; p.y += p.vy * deltaTime; p.vy += PARTICLE_GRAVITY * deltaTime; p.life -= deltaTime; if (p.life <= 0 || p.size < 0.5) { p.active = false; particles.splice(i, 1); } } }
        function drawParticles() { for (let i = 0; i < particles.length; i++) { const p = particles[i]; ctx.globalAlpha = Math.max(0, p.life / p.initialLife); ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); } ctx.globalAlpha = 1.0; }

        // --- Platform Handling ---
        function spawnPlatform(x, y, width, isMoving = false) { const platformWidth = width || (Math.random() * (PLATFORM_MAX_WIDTH - PLATFORM_MIN_WIDTH) + PLATFORM_MIN_WIDTH); const clampedY = Math.max(PLAYER_HEIGHT * 2, y); let pData = { x: x, y: clampedY, width: platformWidth, height: PLATFORM_HEIGHT, type: 'static', vx: 0 }; if (isMoving) { pData.type = 'moving-x'; pData.vx = (Math.random() < 0.5 ? 1 : -1) * PLATFORM_MOVE_SPEED; const mDist = platformWidth * 0.5 + Math.random() * 50; pData.moveRange = [x - mDist, x + mDist]; pData.initialX = x; } platforms.push(pData); }
        function updatePlatforms(deltaTime) { const scrollSpeed = currentObstacleSpeed * deltaTime; for (let i = platforms.length - 1; i >= 0; i--) { const p = platforms[i]; p.x -= scrollSpeed; if (p.type === 'moving-x') { const moveAmount = p.vx * deltaTime; p.x += moveAmount; p.moveRange[0] -= scrollSpeed; p.moveRange[1] -= scrollSpeed; if (p.x <= p.moveRange[0] || p.x + p.width >= p.moveRange[1] + p.width) { p.vx *= -1; p.x = Math.max(p.moveRange[0], Math.min(p.x, p.moveRange[1])); } } if (p.x + p.width < 0) { platforms.splice(i, 1); } } }
        function drawPlatforms() { platforms.forEach(p => { ctx.fillStyle = p.type === 'moving-x' ? tailwind.config.theme.extend.colors['platform-moving'] : tailwind.config.theme.extend.colors.platform; ctx.fillRect(p.x, p.y, p.width, p.height); }); }

        // --- Obstacle Handling ---
        function spawnObstacle(x = BASE_CANVAS_WIDTH, typeOverride = null, yPosOverride = null) { if (isGameOver) return; let type = typeOverride; let yPos = yPosOverride; let emoji, h, w; let shootTimer = 0; if (!type) { const r = Math.random(); if (r < 0.4) { type = 'tall'; } else if (r < 0.75) { type = 'short'; } else { type = 'flying'; } } if (type === 'tall') { h = OBSTACLE_HEIGHT_TALL; w = OBSTACLE_WIDTH; yPos = yPosOverride ?? GROUND_Y - h; emoji = EMOJI_OBSTACLE_TALL; } else if (type === 'short') { h = OBSTACLE_HEIGHT_SHORT; w = OBSTACLE_WIDTH; yPos = yPosOverride ?? GROUND_Y - h; emoji = EMOJI_OBSTACLE_SHORT; } else if (type === 'flying') { h = OBSTACLE_FLYING_SIZE; w = OBSTACLE_FLYING_SIZE; yPos = yPosOverride ?? (BASE_CANVAS_HEIGHT * 0.5 - Math.random() * (BASE_CANVAS_HEIGHT * 0.4)); yPos = Math.max(PLAYER_HEIGHT, Math.min(yPos, GROUND_Y - PLAYER_HEIGHT * 2)); emoji = EMOJI_OBSTACLE_FLYING; shootTimer = FLYING_SHOOT_COOLDOWN_SECONDS / 2 + Math.random() * FLYING_SHOOT_COOLDOWN_SECONDS / 2; } else { return; } obstacles.push({ x: x, y: yPos, width: w, height: h, speed: currentObstacleSpeed, emoji: emoji, type: type, shootTimer: shootTimer }); }
        function updateObstacles(deltaTime) { for (let i = obstacles.length - 1; i >= 0; i--) { const o = obstacles[i]; o.x -= o.speed * deltaTime; if (o.type === 'flying' && !isGameOver) { o.shootTimer -= deltaTime; if (o.shootTimer <= 0 && o.x < BASE_CANVAS_WIDTH && o.x + o.width > 0) { spawnProjectile(o.x + o.width / 2, o.y + o.height); o.shootTimer = FLYING_SHOOT_COOLDOWN_SECONDS; if (projectileShootSynth && audioInitialized) { try { projectileShootSynth.triggerAttackRelease("4n"); } catch(err){ console.error("Shoot sound error:", err); } } } } if (o.x + o.width < 0) { obstacles.splice(i, 1); } } }
        function drawObstacles() { ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; obstacles.forEach(o => { const fs = o.height * 0.9; ctx.font = `${fs}px Arial`; const dX = o.x + o.width / 2; const dY = o.y + o.height / 2; ctx.fillText(o.emoji, dX, dY); }); }

        // --- Projectile Handling ---
        function spawnProjectile(x, y) { projectiles.push({ x: x - PROJECTILE_WIDTH / 2, y: y, width: PROJECTILE_WIDTH, height: PROJECTILE_HEIGHT, vy: PROJECTILE_SPEED }); }
        function updateProjectiles(deltaTime) { for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.y += p.vy * deltaTime; if (p.y > BASE_CANVAS_HEIGHT) { projectiles.splice(i, 1); } } }
        function drawProjectiles() { ctx.fillStyle = tailwind.config.theme.extend.colors.projectile; projectiles.forEach(p => { ctx.fillRect(p.x, p.y, p.width, p.height); }); }

        // --- Collectible Handling ---
        function spawnCollectible(x = BASE_CANVAS_WIDTH + Math.random() * 50, yPos = null) { if (isGameOver) return; let y = yPos; if (y === null) { const p = platforms.find(pf => pf.x > BASE_CANVAS_WIDTH / 2 && pf.x < BASE_CANVAS_WIDTH); if (p && Math.random() < 0.4) { y = p.y - COLLECTIBLE_SIZE - 2; } else if (Math.random() < 0.4) { y = GROUND_Y - PLAYER_HEIGHT * 1.5 - (Math.random() * 50); } else { y = GROUND_Y - COLLECTIBLE_SIZE - 5 - (Math.random() * 10); } y = Math.max(10, Math.min(y, GROUND_Y - COLLECTIBLE_SIZE - 5)); } collectibles.push({ x: x, y: y, width: COLLECTIBLE_SIZE, height: COLLECTIBLE_SIZE, value: COLLECTIBLE_VALUE, speed: currentObstacleSpeed, emoji: EMOJI_COLLECTIBLE }); }
        function updateCollectibles(deltaTime) { for (let i = collectibles.length - 1; i >= 0; i--) { const c = collectibles[i]; c.x -= c.speed * deltaTime; if (c.x + c.width < 0) { collectibles.splice(i, 1); } } }
        function drawCollectibles() { const fs = COLLECTIBLE_SIZE * 1.2; ctx.font = `${fs}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; collectibles.forEach(c => { const dX = c.x + c.width / 2; const dY = c.y + c.height / 2; ctx.fillText(c.emoji, dX, dY); }); }

        // --- Powerup Handling ---
         function spawnPowerup(x = BASE_CANVAS_WIDTH + Math.random() * 100, yPos = null) { if (isGameOver) return; let y = yPos; if (y === null) { const p = platforms.find(pf => pf.x > BASE_CANVAS_WIDTH / 2 && pf.x < BASE_CANVAS_WIDTH); if (p && Math.random() < 0.5) { y = p.y - POWERUP_SIZE - 3; } else { y = GROUND_Y - PLAYER_HEIGHT * 1.5 - (Math.random() * 50); } y = Math.max(15, Math.min(y, GROUND_Y - POWERUP_SIZE - 10)); } const type = Math.random() < 0.5 ? 'shield' : 'multiplier'; const emoji = type === 'shield' ? EMOJI_POWERUP_SHIELD : EMOJI_POWERUP_MULTIPLIER; powerups.push({ x: x, y: y, width: POWERUP_SIZE, height: POWERUP_SIZE, speed: currentObstacleSpeed * 0.8, emoji: emoji, type: type }); }
         function updatePowerups(deltaTime) { for (let i = powerups.length - 1; i >= 0; i--) { const p = powerups[i]; p.x -= p.speed * deltaTime; if (p.x + p.width < 0) { powerups.splice(i, 1); } } }
         function drawPowerups() { const fs = POWERUP_SIZE * 1.1; ctx.font = `${fs}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; powerups.forEach(p => { const dX = p.x + p.width / 2; const dY = p.y + p.height / 2; ctx.fillText(p.emoji, dX, dY); }); }

        // --- Pattern Spawning ---
        function spawnWallJumpPattern() { const startX = BASE_CANVAS_WIDTH + 50; const wallHeight = OBSTACLE_HEIGHT_TALL; const gapWidth = PLAYER_WIDTH * 2.5; const yPos = GROUND_Y - wallHeight; spawnObstacle(startX, 'tall', yPos); spawnObstacle(startX + OBSTACLE_WIDTH + gapWidth, 'tall', yPos); spawnCollectible(startX + OBSTACLE_WIDTH + gapWidth / 2, yPos - PLAYER_HEIGHT * 0.8); }
        function spawnPlatformHopPattern() { const startX = BASE_CANVAS_WIDTH + 30; const platWidth = PLATFORM_MIN_WIDTH * 0.8; const y1 = GROUND_Y - PLAYER_HEIGHT * 1.2; const y2 = GROUND_Y - PLAYER_HEIGHT * 2.2; const gap = PLAYER_WIDTH * 1.8; spawnPlatform(startX, y1, platWidth); spawnPlatform(startX + platWidth + gap, y2, platWidth); spawnCollectible(startX + platWidth + gap + platWidth / 2, y2 - COLLECTIBLE_SIZE * 1.5); }

        // --- Collision Detection ---
        function isHorizontallyClose(item, buffer = COLLISION_X_BUFFER) { return item.x < player.x + PLAYER_WIDTH + buffer && item.x + item.width > player.x - buffer; }
        function checkCollision(rect1, rect2) { return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y ); }

        // --- Input Handling ---
        function handleKeyDown(e) { if (isGameOver) return; keys[e.key] = true; if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' ', 'Spacebar', DASH_KEY].includes(e.key)) e.preventDefault(); if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'Spacebar')) { triggerJump(); } else if (e.key === DASH_KEY) { triggerDash(); } }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- Touch Input Handling ---
        function handleTouchStart(e) { if (isGameOver) return; e.preventDefault(); const targetId = e.target.id; if (targetId === 'touch-left') keys['ArrowLeft'] = true; else if (targetId === 'touch-right') keys['ArrowRight'] = true; else if (targetId === 'touch-jump') triggerJump(); else if (targetId === 'touch-dash') triggerDash(); }
        function handleTouchEnd(e) { e.preventDefault(); const targetId = e.target.id; if (targetId === 'touch-left') keys['ArrowLeft'] = false; else if (targetId === 'touch-right') keys['ArrowRight'] = false; }

        // --- Action Triggers ---
        function triggerJump() { if (player.jumpsRemaining > 0 && !player.isDashing) { player.dy = -player.jumpStrength; player.isOnGround = false; player.landedOnPlatform = null; player.jumpsRemaining--; const pColor = player.jumpsRemaining === 0 ? tailwind.config.theme.extend.colors['particle-double-jump'] : tailwind.config.theme.extend.colors['particle-jump']; spawnParticles(player.jumpsRemaining === 0 ? 10 : 5, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT, pColor, 2 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS, PARTICLE_MAX_LIFE_SECONDS], 1 * TARGET_FPS); if (jumpSynth && audioInitialized) { try { jumpSynth.frequency.setValueAtTime(player.jumpsRemaining === 0 ? "D5" : "C5", Tone.now()); jumpSynth.triggerAttackRelease("8n"); } catch(err){ console.error("Jump sound error:", err); } } } }
        function triggerDash() { if (player.dashCooldownTimer <= 0 && !player.isDashing) { player.isDashing = true; player.dashTimer = DASH_DURATION_SECONDS; player.dashCooldownTimer = DASH_COOLDOWN_SECONDS; const horizontalInput = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0); player.dashDirection = horizontalInput !== 0 ? horizontalInput : (player.dx > 0 ? 1 : (player.dx < 0 ? -1 : 1)); if (player.isOnGround) { player.dy = 0; } else { player.dy = player.dy * 0.5; } spawnParticles(15, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, tailwind.config.theme.extend.colors['particle-dash'], 4 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS * 0.5, PARTICLE_MAX_LIFE_SECONDS * 0.8], 0, -player.dashDirection * 2 * TARGET_FPS); if (dashSynth && audioInitialized) { try { dashSynth.triggerAttackRelease("A4", "16n"); } catch(err){ console.error("Dash sound error:", err); } } } }

        // --- Add/Remove Input Listeners ---
        function addInputListeners() { removeInputListeners(); window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp); touchLeftBtn.addEventListener('touchstart', handleTouchStart, { passive: false }); touchLeftBtn.addEventListener('touchend', handleTouchEnd); touchRightBtn.addEventListener('touchstart', handleTouchStart, { passive: false }); touchRightBtn.addEventListener('touchend', handleTouchEnd); touchJumpBtn.addEventListener('touchstart', handleTouchStart, { passive: false }); touchDashBtn.addEventListener('touchstart', handleTouchStart, { passive: false }); }
        function removeInputListeners() { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); touchLeftBtn.removeEventListener('touchstart', handleTouchStart); touchLeftBtn.removeEventListener('touchend', handleTouchEnd); touchRightBtn.removeEventListener('touchstart', handleTouchStart); touchRightBtn.removeEventListener('touchend', handleTouchEnd); touchJumpBtn.removeEventListener('touchstart', handleTouchStart); touchDashBtn.removeEventListener('touchstart', handleTouchStart); }

        // --- Player Update ---
        function updatePlayerState(deltaTime) { try { player.wasOnGround = player.isOnGround; let platformVx = 0; if (player.isInvincible) { player.invincibilityTimer -= deltaTime; if (player.invincibilityTimer <= 0) { player.isInvincible = false; } } if (player.scoreMultiplierTimer > 0) { player.scoreMultiplierTimer -= deltaTime; if (player.scoreMultiplierTimer <= 0) { player.scoreMultiplier = 1; scoreDisplay.classList.remove('multiplier-active'); } else { scoreDisplay.classList.add('multiplier-active'); } } if (player.dashCooldownTimer > 0) { player.dashCooldownTimer -= deltaTime; } let currentSpeed = player.speed; if (player.isDashing) { player.dashTimer -= deltaTime; currentSpeed *= DASH_SPEED_MULTIPLIER; player.x += player.dashDirection * currentSpeed * deltaTime; if (player.dashTimer <= 0) { player.isDashing = false; } player.dx = 0; } else { player.dx = 0; if (keys['ArrowLeft']) player.dx = -currentSpeed; if (keys['ArrowRight']) player.dx = currentSpeed; player.x += player.dx * deltaTime; player.dy += player.gravity * deltaTime; } if (player.landedOnPlatform?.type === 'moving-x') { platformVx = player.landedOnPlatform.vx || 0; if (!player.isDashing) { player.x += platformVx * deltaTime; } } player.x = Math.max(0, Math.min(player.x, BASE_CANVAS_WIDTH - player.width)); let potentialY = player.y + player.dy * deltaTime; let landedOnSomething = false; let landingSurfaceY = GROUND_Y; let currentPlatform = null; if (player.dy >= 0) { for (const platform of platforms) { if (isHorizontallyClose(platform)) { if (player.x + PLAYER_WIDTH > platform.x && player.x < platform.x + platform.width) { if (player.y + PLAYER_HEIGHT <= platform.y + 1 && potentialY + PLAYER_HEIGHT >= platform.y) { potentialY = platform.y - PLAYER_HEIGHT; player.dy = 0; landedOnSomething = true; landingSurfaceY = platform.y; currentPlatform = platform; break; } } } } if (!landedOnSomething && potentialY + PLAYER_HEIGHT >= GROUND_Y) { potentialY = GROUND_Y - PLAYER_HEIGHT; player.dy = 0; landedOnSomething = true; landingSurfaceY = GROUND_Y; currentPlatform = null; } } player.y = potentialY; player.isOnGround = landedOnSomething; player.landedOnPlatform = landedOnSomething ? currentPlatform : null; if (player.isOnGround) { player.jumpsRemaining = MAX_JUMPS; if (!player.wasOnGround) { spawnParticles(4, player.x + PLAYER_WIDTH / 2, landingSurfaceY, tailwind.config.theme.extend.colors['particle-jump'], 1.5 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS, PARTICLE_MAX_LIFE_SECONDS * 0.8], -0.5 * TARGET_FPS); } } if (player.y < 0) { player.y = 0; player.dy = 0; } if (player.y + PLAYER_HEIGHT > GROUND_Y + LAVA_HEIGHT / 2 && !isGameOver) { handleGameOver(); } } catch (e) { console.error("Error in updatePlayerState:", e); handleGameOver(); } }

        // --- Drawing Functions ---
        function clearCanvas() { ctx.clearRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT); }
        function drawEnvironment() { ctx.fillStyle = tailwind.config.theme.extend.colors.ground; ctx.fillRect(0, GROUND_Y, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT - GROUND_Y); ctx.fillStyle = tailwind.config.theme.extend.colors.lava; ctx.fillRect(0, GROUND_Y + PLATFORM_HEIGHT / 2, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT - (GROUND_Y + PLATFORM_HEIGHT / 2)); }
        function drawPlayer() { const isInvulnerable = player.isInvincible || (player.isDashing && DASH_INVINCIBILITY); if (isInvulnerable) { const alpha = 0.6 + Math.sin(Date.now() / 150) * 0.2; ctx.globalAlpha = Math.max(0.4, alpha); } if (player.image && !player.isPlaceholder && player.image.complete) { ctx.drawImage(player.image, player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT); } else { ctx.fillStyle = tailwind.config.theme.extend.colors['placeholder-bg']; ctx.fillRect(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT); ctx.fillStyle = tailwind.config.theme.extend.colors['placeholder-text']; ctx.font = '12px Inter'; ctx.textAlign = 'center'; const placeholderName = selectedCharacter?.name?.split(' ')[0] || '?'; ctx.fillText(placeholderName, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2 + 5); } ctx.globalAlpha = 1.0; }
        function drawScore() { scoreDisplay.textContent = `Score: ${score}`; }

        // --- Game Over Handling ---
        function handleGameOver() { if(isGameOver) return; isGameOver = true; stopMusic(); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; lastTimestamp = 0; removeInputListeners(); window.removeEventListener('resize', handleResize); console.log("Game Over! Final Score:", score); screenShakeActive = true; screenShakeTimer = SCREEN_SHAKE_DURATION_SECONDS; spawnParticles(25, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, tailwind.config.theme.extend.colors['particle-gameover'], 4 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS * 1.5, PARTICLE_MAX_LIFE_SECONDS * 1.5]); if (gameOverSynth && audioInitialized) { try { gameOverSynth.triggerAttackRelease("C3", "2n"); } catch(err){ console.error("Game over sound error:", err); } } let gameOverText = `Game Over!\nScore: ${score}`; if (score > highScore) { console.log(`New high score: ${score} (previous: ${highScore})`); highScore = score; try { localStorage.setItem(STORAGE_KEY, highScore); highScoreDisplay.textContent = `High Score: ${highScore}`; gameOverText += "\n(New High Score!)"; } catch (e) { console.error("Could not save high score to localStorage:", e); } } gameOverMessage.textContent = gameOverText; gameOverMessage.classList.remove('hidden'); restartBtn.classList.remove('hidden'); backToSelectBtn.disabled = true; }

        // --- Game Loop ---
        function gameLoop(timestamp) {
             if (isGameOver) { return; }
             if (lastTimestamp === 0) lastTimestamp = timestamp; // Handle first frame
             const deltaTime = (timestamp - lastTimestamp) / 1000; lastTimestamp = timestamp;
             const clampedDeltaTime = Math.min(deltaTime, 1 / 20); // Prevent large jumps

             try {
                 let shakeOffsetX = 0, shakeOffsetY = 0;
                 if (screenShakeActive && screenShakeTimer > 0) { screenShakeTimer -= clampedDeltaTime; const magnitude = SCREEN_SHAKE_MAGNITUDE * (screenShakeTimer / SCREEN_SHAKE_DURATION_SECONDS); shakeOffsetX = (Math.random() - 0.5) * magnitude * 2; shakeOffsetY = (Math.random() - 0.5) * magnitude * 2; ctx.save(); ctx.translate(shakeOffsetX, shakeOffsetY); if (screenShakeTimer <= 0) screenShakeActive = false; }

                 const scrollAmount = currentObstacleSpeed * clampedDeltaTime;
                 backgroundOffset1 += scrollAmount * 0.05; backgroundOffset2 += scrollAmount * 0.15; backgroundOffset3 += scrollAmount * 0.3;
                 canvas.style.backgroundPositionX = `${-backgroundOffset3}px, ${-backgroundOffset2}px, ${-backgroundOffset1}px`;

                 clearCanvas();

                 currentObstacleSpeed = Math.min(MAX_OBSTACLE_SPEED, BASE_OBSTACLE_SPEED + Math.floor(score / SCORE_SPEED_INCREASE_THRESHOLD) * (0.25 * TARGET_FPS));
                 currentSpawnIntervalSeconds = Math.max(MIN_SPAWN_INTERVAL_SECONDS, BASE_SPAWN_INTERVAL_SECONDS - Math.floor(score / SCORE_INTERVAL_DECREASE_THRESHOLD) * (10 / TARGET_FPS));

                 try { updatePlayerState(clampedDeltaTime); updateObstacles(clampedDeltaTime); updateCollectibles(clampedDeltaTime); updatePowerups(clampedDeltaTime); updateParticles(clampedDeltaTime); updatePlatforms(clampedDeltaTime); updateProjectiles(clampedDeltaTime); } catch (e) { console.error("Error during Updates:", e); handleGameOver(); return; }
                 try { timeSinceLastObstacleSpawn += clampedDeltaTime; timeSinceLastPlatform += clampedDeltaTime; timeSinceLastPattern += clampedDeltaTime; let didSpawnPattern = false; if (timeSinceLastPattern >= PATTERN_MIN_INTERVAL_SECONDS && Math.random() < PATTERN_SPAWN_CHANCE) { const patternChoice = Math.random(); if (patternChoice < 0.5) { spawnWallJumpPattern(); } else { spawnPlatformHopPattern(); } timeSinceLastPattern = 0; timeSinceLastObstacleSpawn = -BASE_SPAWN_INTERVAL_SECONDS; didSpawnPattern = true; } if (!didSpawnPattern && timeSinceLastObstacleSpawn >= currentSpawnIntervalSeconds) { if (timeSinceLastPlatform > currentSpawnIntervalSeconds * 4 && Math.random() < PLATFORM_SPAWN_CHANCE) { spawnPlatformGroup(); timeSinceLastPlatform = 0; } else { spawnObstacle(); } timeSinceLastObstacleSpawn = 0; } timeSinceLastCollectibleSpawn += clampedDeltaTime; if (timeSinceLastCollectibleSpawn >= COLLECTIBLE_SPAWN_INTERVAL_SECONDS) { spawnCollectible(); timeSinceLastCollectibleSpawn = 0; } timeSinceLastPowerupSpawn += clampedDeltaTime; if (timeSinceLastPowerupSpawn >= POWERUP_SPAWN_INTERVAL_SECONDS) { spawnPowerup(); timeSinceLastPowerupSpawn = 0; } } catch (e) { console.error("Error during Spawning:", e); handleGameOver(); return; }
                 try { const isPlayerVulnerable = !player.isInvincible && !(player.isDashing && DASH_INVINCIBILITY); if (isPlayerVulnerable) { for (let obs of obstacles) { if (isHorizontallyClose(obs) && checkCollision(player, obs)) { handleGameOver(); return; } } for (let i = projectiles.length - 1; i >= 0; i--) { const proj = projectiles[i]; if (isHorizontallyClose(proj, 20) && checkCollision(player, proj)) { projectiles.splice(i, 1); handleGameOver(); return; } } } for (let i = collectibles.length - 1; i >= 0; i--) { const coll = collectibles[i]; if (isHorizontallyClose(coll) && checkCollision(player, coll)) { score += coll.value * player.scoreMultiplier; spawnParticles(8, coll.x + coll.width / 2, coll.y + coll.height / 2, tailwind.config.theme.extend.colors['particle-collect'], 2.5 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS, PARTICLE_MAX_LIFE_SECONDS]); collectibles.splice(i, 1); if (collectSynth && audioInitialized) { try { collectSynth.triggerAttackRelease("E5", "16n"); } catch(err){ console.error("Collect sound error:", err); } } } } for (let i = powerups.length - 1; i >= 0; i--) { const pow = powerups[i]; if (isHorizontallyClose(pow) && checkCollision(player, pow)) { const powerupType = pow.type; powerups.splice(i, 1); if (powerupType === 'shield') { spawnParticles(12, pow.x + pow.width / 2, pow.y + pow.height / 2, tailwind.config.theme.extend.colors['particle-powerup-shield'], 3 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS, PARTICLE_MAX_LIFE_SECONDS]); player.isInvincible = true; player.invincibilityTimer = POWERUP_SHIELD_DURATION_SECONDS; console.log("Shield Activated!"); if (powerupShieldSynth && audioInitialized) { try { const now = Tone.now(); powerupShieldSynth.triggerAttackRelease("C4", "16n", now); powerupShieldSynth.triggerAttackRelease("E4", "16n", now + 0.1); powerupShieldSynth.triggerAttackRelease("G4", "16n", now + 0.2); } catch (err) { console.error("Powerup sound error:", err); } } } else if (powerupType === 'multiplier') { spawnParticles(12, pow.x + pow.width / 2, pow.y + pow.height / 2, tailwind.config.theme.extend.colors['particle-powerup-multiplier'], 3 * TARGET_FPS, [PARTICLE_MIN_LIFE_SECONDS, PARTICLE_MAX_LIFE_SECONDS]); player.scoreMultiplier = SCORE_MULTIPLIER_VALUE; player.scoreMultiplierTimer = MULTIPLIER_DURATION_SECONDS; console.log("Score Multiplier Activated!"); scoreDisplay.classList.add('multiplier-active'); if (powerupMultiplierSynth && audioInitialized) { try { const now = Tone.now(); powerupMultiplierSynth.triggerAttackRelease("G4", "16n", now); powerupMultiplierSynth.triggerAttackRelease("C5", "16n", now + 0.1); powerupMultiplierSynth.triggerAttackRelease("E5", "16n", now + 0.2); } catch (err) { console.error("Powerup sound error:", err); } } } } } } catch (e) { console.error("Error during Collisions:", e); handleGameOver(); return; }
                 try { drawEnvironment(); drawPlatforms(); drawObstacles(); drawCollectibles(); drawPowerups(); drawProjectiles(); drawPlayer(); drawParticles(); drawScore(); } catch (e) { console.error("Error during Drawing:", e); handleGameOver(); return; }

                 if (screenShakeActive) { ctx.restore(); }
                 animationFrameId = requestAnimationFrame(gameLoop); // Request next frame

             } catch (e) { console.error("CRITICAL ERROR in gameLoop:", e); handleGameOver(); }
        }

        // --- Helper Functions ---
        function spawnPlatformGroup() { const startX = BASE_CANVAS_WIDTH + 50; const numPlatforms = Math.floor(Math.random() * 3) + 2; let currentX = startX; let lastY = GROUND_Y - PLAYER_HEIGHT * (1 + Math.random() * 1.5); for (let i = 0; i < numPlatforms; i++) { const width = Math.random() * (PLATFORM_MAX_WIDTH - PLATFORM_MIN_WIDTH) + PLATFORM_MIN_WIDTH; const isMoving = Math.random() < 0.3; const nextY = Math.max(PLAYER_HEIGHT * 2, lastY + (Math.random() - 0.5) * PLAYER_HEIGHT * 2); spawnPlatform(currentX, nextY, width, isMoving); if (Math.random() < 0.6) { spawnCollectible(currentX + width / 2, nextY - COLLECTIBLE_SIZE * 1.5); } lastY = nextY; currentX += width + PLAYER_WIDTH * (1.5 + Math.random()); } timeSinceLastPlatform = 0; }

        // --- Initial Setup ---
        window.addEventListener('load', resizeCanvas); // Resize on initial load

    </script>
</body>
</html>
