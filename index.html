<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Platformer Game - HAZARDS!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // Configure Tailwind CSS
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    boxShadow: {
                        'glow': '0 0 15px 5px rgba(99, 102, 241, 0.5)',
                    },
                    colors: {
                        'placeholder-bg': '#a0aec0', 'placeholder-text': '#ffffff', 'game-bg': '#f0f9ff',
                        'ground': '#e5e7eb', 'platform': '#a78bfa', 'platform-moving': '#c4b5fd',
                        'lava': '#fb923c', // Orange for lava/hazard
                        'obstacle': '#ef4444', 'obstacle-short': '#f97316', 'obstacle-flying': '#a3e635',
                        'projectile': '#fca5a5',
                        'collectible': '#facc15', 'powerup-shield': '#60a5fa', 'powerup-multiplier': '#f472b6',
                        'particle-jump': '#cbd5e1', 'particle-double-jump': '#fde047',
                        'particle-collect': '#fde047', 'particle-powerup-shield': '#93c5fd', 'particle-powerup-multiplier': '#fda4af',
                        'particle-dash': '#ffffff', 'particle-gameover': '#f87171',
                        'score-text': '#374151', 'score-text-multi': '#ec4899',
                        'game-over-text': '#dc2626', 'page-bg': '#e5e7eb', 'text-main': '#1f2937',
                        'text-light': '#4b5563', 'button-text': '#ffffff',
                        'bg-layer-1': '#e0f2fe', 'bg-layer-2': '#d1d5db', 'bg-layer-3': '#9ca3af',
                        'highscore-text': '#6b7280'
                    }
                }
            }
        }
    </script>
    <style>
        /* Basic styling */
        body { font-family: 'Inter', sans-serif; background-color: theme('colors.page-bg'); color: theme('colors.text-main'); display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 1rem; overflow: hidden; }
        .character-card.selected { border-color: #6366f1; box-shadow: 0 0 15px 5px rgba(99, 102, 241, 0.5); transform: scale(1.05); }
        .character-card, button { transition: all 0.2s ease-in-out; }
        .character-card img { display: block; margin-left: auto; margin-right: auto; margin-bottom: 0.5rem; max-width: 100%; height: auto; aspect-ratio: 1 / 1; object-fit: contain; background-color: #e5e7eb; border-radius: 0.25rem; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:hover:not(:disabled) { filter: brightness(1.1); }
        .hidden { display: none; }
        /* Canvas style */
        #gameCanvas {
            background-color: theme('colors.game-bg'); border-radius: 0.5rem; border: 1px solid theme('colors.gray.300');
            display: block; max-width: 100%; position: relative;
            background-image: linear-gradient(theme('colors.bg-layer-3') 1px, transparent 1px), radial-gradient(theme('colors.bg-layer-2') 1px, transparent 1px), linear-gradient(to bottom, theme('colors.bg-layer-1') 1px, transparent 1px);
            background-size: 10px 10px, 15px 15px, 100% 25px;
            background-position: 0 0, 0 0, 0 0;
            background-repeat: repeat, repeat, repeat-x;
        }
        /* Container style */
        .main-container { background-color: theme('colors.white'); border-radius: 0.5rem; box-shadow: theme('boxShadow.xl'); padding: 1.5rem; text-align: center; width: 100%; max-width: 600px; position: relative; color: theme('colors.text-main'); }
        /* Score display */
        #score-display { position: absolute; top: 1.5rem; left: 1.5rem; font-size: 1.5rem; font-weight: bold; color: theme('colors.score-text'); z-index: 10; transition: color 0.3s ease; }
        #score-display.multiplier-active { color: theme('colors.score-text-multi'); }
        /* High Score display */
        #high-score-display { position: absolute; top: 1.8rem; right: 1.5rem; font-size: 1rem; font-weight: normal; color: theme('colors.highscore-text'); z-index: 10; }
        /* Game Over message */
        #game-over-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2.25rem; font-weight: bold; color: theme('colors.game-over-text'); text-shadow: 1px 1px 2px rgba(0,0,0,0.2); z-index: 20; text-align: center; white-space: pre-wrap; }
        #selected-character-info { color: theme('colors.text-light'); }
    </style>
</head>
<body class="bg-page-bg text-text-main">

    <div id="character-select-container" class="main-container">
         <h1 class="text-4xl font-bold mb-8 text-indigo-600">Choose Your Character</h1>
        <div id="character-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-6 mb-8">
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="blocky-adventurer" data-character-name="Blocky Adventurer" data-character-img="https://i.imgur.com/hOAkq4W.png"> <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/hOAkq4W.png" alt="Blocky Adventurer" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';"> <span class="font-semibold text-text-main">Blocky Adventurer</span> </div>
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="aqua-block" data-character-name="Aqua Block" data-character-img="https://i.imgur.com/mcrXKUb.png"> <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/mcrXKUb.png" alt="Aqua Block" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';"> <span class="font-semibold text-text-main">Aqua Block</span> </div>
             <div class="character-card bg-gray-100 hover:bg-gray-200 p-4 rounded-lg border-2 border-transparent hover:border-indigo-500 cursor-pointer flex flex-col items-center" data-character-id="crimson-cube" data-character-name="Crimson Cube" data-character-img="https://i.imgur.com/al29Ve1.png"> <img class="aspect-square object-contain h-auto max-w-full mx-auto mb-2 rounded bg-gray-200" src="https://i.imgur.com/al29Ve1.png" alt="Crimson Cube" onerror="this.onerror=null; this.src='https://placehold.co/200x200/a0aec0/ffffff?text=Img+Error';"> <span class="font-semibold text-text-main">Crimson Cube</span> </div>
        </div>
        <div id="selected-character-info" class="mb-8 h-8 text-lg"> Select a character to begin! </div>
        <button id="start-game-btn" class="bg-indigo-600 hover:bg-indigo-700 text-button-text font-bold py-3 px-8 rounded-lg text-xl shadow-md" disabled> Start Game </button>
    </div>

    <div id="game-area-container" class="main-container hidden">
         <div id="score-display">Score: 0</div>
         <div id="high-score-display">High Score: 0</div>
         <div id="game-over-message" class="hidden">Game Over!</div>
         <h2 id="game-title" class="text-3xl font-bold mb-1 text-indigo-600 invisible">Game Area</h2>
         <canvas id="gameCanvas" width="550" height="350" class="mx-auto mb-4"></canvas>
         <div class="flex justify-center space-x-4"> <button id="back-to-select-btn" class="bg-gray-500 hover:bg-gray-600 text-button-text font-bold py-2 px-6 rounded-lg shadow-md"> Back to Select </button> <button id="restart-btn" class="bg-green-600 hover:bg-green-700 text-button-text font-bold py-2 px-6 rounded-lg shadow-md hidden"> Restart </button> </div>
    </div>

    <script>
        // --- DOM Elements ---
        const characterSelectContainer = document.getElementById('character-select-container');
        const gameAreaContainer = document.getElementById('game-area-container');
        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const gameOverMessage = document.getElementById('game-over-message');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startGameBtn = document.getElementById('start-game-btn');
        const backToSelectBtn = document.getElementById('back-to-select-btn');
        const restartBtn = document.getElementById('restart-btn');
        const characterCards = document.querySelectorAll('.character-card');
        const selectedCharacterInfo = document.getElementById('selected-character-info');

        // --- Game Constants ---
        const GRAVITY = 0.5; const JUMP_STRENGTH = 10; const MAX_JUMPS = 2;
        const GROUND_Y = canvas.height - 25; const LAVA_HEIGHT = 10; // Height of the lava visual
        const PLAYER_WIDTH = 40; const PLAYER_HEIGHT = 40; const PLAYER_SPEED = 4;
        const DASH_KEY = 'Shift'; const DASH_DURATION_FRAMES = 10; const DASH_SPEED_MULTIPLIER = 3; const DASH_COOLDOWN_FRAMES = 60; const DASH_INVINCIBILITY = true;
        const OBSTACLE_WIDTH = 25; const OBSTACLE_HEIGHT_TALL = 40; const OBSTACLE_HEIGHT_SHORT = 20; const OBSTACLE_FLYING_SIZE = 30;
        const BASE_OBSTACLE_SPEED = 3; const MAX_OBSTACLE_SPEED = 7; const BASE_SPAWN_INTERVAL_FRAMES = 100; const MIN_SPAWN_INTERVAL_FRAMES = 45;
        const SCORE_SPEED_INCREASE_THRESHOLD = 300; const SCORE_INTERVAL_DECREASE_THRESHOLD = 600;
        const COLLECTIBLE_SIZE = 15; const COLLECTIBLE_VALUE = 50; const COLLECTIBLE_SPAWN_INTERVAL_FRAMES = 150;
        const POWERUP_SIZE = 20; const POWERUP_SPAWN_INTERVAL_FRAMES = 650;
        const POWERUP_SHIELD_DURATION_FRAMES = 300; const MULTIPLIER_DURATION_FRAMES = 400; const SCORE_MULTIPLIER_VALUE = 3;
        const EMOJI_OBSTACLE_TALL = '🧱'; const EMOJI_OBSTACLE_SHORT = '🪨'; const EMOJI_OBSTACLE_FLYING = '👻'; const EMOJI_COLLECTIBLE = '⭐'; const EMOJI_POWERUP_SHIELD = '🛡️'; const EMOJI_POWERUP_MULTIPLIER = '✨';
        const STORAGE_KEY = 'blockyGameHighScore';
        const PARTICLE_GRAVITY = 0.05; const PARTICLE_MIN_LIFE = 15; const PARTICLE_MAX_LIFE = 35;
        const SCREEN_SHAKE_DURATION = 15; const SCREEN_SHAKE_MAGNITUDE = 4;
        const PLATFORM_HEIGHT = 15; const PLATFORM_MIN_WIDTH = 80; const PLATFORM_MAX_WIDTH = 150; const PLATFORM_SPAWN_CHANCE = 0.2;
        const PLATFORM_MOVE_SPEED = 0.8;
        const COLLISION_X_BUFFER = 100;
        const PROJECTILE_WIDTH = 5; const PROJECTILE_HEIGHT = 10; const PROJECTILE_SPEED = 3; const FLYING_SHOOT_COOLDOWN = 120;
        const PATTERN_SPAWN_CHANCE = 0.1; // Chance to spawn a pattern instead of random stuff
        const PATTERN_MIN_INTERVAL_FRAMES = 180; // Min frames between patterns

        // --- Game State ---
        let selectedCharacter = null; let player = {}; let keys = {}; let obstacles = []; let collectibles = []; let powerups = []; let particles = []; let platforms = []; let projectiles = [];
        let score = 0; let highScore = 0;
        let isGameOver = false; let animationFrameId = null;
        let currentObstacleSpeed = BASE_OBSTACLE_SPEED; let currentSpawnIntervalFrames = BASE_SPAWN_INTERVAL_FRAMES;
        let timeSinceLastObstacleSpawn = 0; let timeSinceLastCollectibleSpawn = 0; let timeSinceLastPowerupSpawn = 0; let timeSinceLastPlatform = 0; let timeSinceLastPattern = PATTERN_MIN_INTERVAL_FRAMES; // Timer for pattern spacing
        let backgroundOffset1 = 0; let backgroundOffset2 = 0; let backgroundOffset3 = 0;
        let screenShakeActive = false; let screenShakeTimer = 0;

        // --- Audio State & Synths ---
        let audioInitialized = false; let jumpSynth = null; let collectSynth = null; let gameOverSynth = null; let powerupShieldSynth = null; let powerupMultiplierSynth = null; let projectileShootSynth = null; let dashSynth = null; let bgMusicSynth = null; let musicLoop = null;
        if (typeof Tone !== 'undefined') { try { /* ... synth definitions ... */ jumpSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination(); collectSynth = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination(); gameOverSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 } }).toDestination(); powerupShieldSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(); powerupMultiplierSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.3 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 } }).toDestination(); projectileShootSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }, volume: -15 }).toDestination(); dashSynth = new Tone.Synth({ oscillator: { type: 'triangle8' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }, volume: -10 }).toDestination(); bgMusicSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }, volume: -18 }).toDestination(); const musicSequence = ["C3", ["E3", "G3"], "C4", ["E3", "G3"]]; let musicStep = 0; musicLoop = new Tone.Loop(time => { let note = musicSequence[musicStep % musicSequence.length]; bgMusicSynth.triggerAttackRelease(note, "8n", time); musicStep++; }, "4n"); } catch (e) { console.error("Error creating Tone.js synths:", e); } } else { console.warn("Tone.js not loaded, sound effects disabled."); }

        // --- Load High Score ---
        try { const storedHighScore = localStorage.getItem(STORAGE_KEY); if (storedHighScore) { highScore = parseInt(storedHighScore, 10) || 0; } } catch (e) { console.error("Could not load high score from localStorage:", e); highScore = 0; }

        // --- Character Selection Logic ---
        characterCards.forEach(card => { card.addEventListener('click', () => { characterCards.forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedCharacter = { id: card.dataset.characterId, name: card.dataset.characterName, imgSrc: card.dataset.characterImg }; selectedCharacterInfo.textContent = `Selected: ${selectedCharacter.name}`; startGameBtn.disabled = false; }); });

        // --- Screen Transition Logic ---
        startGameBtn.addEventListener('click', async () => { if (selectedCharacter) { characterSelectContainer.classList.add('hidden'); gameAreaContainer.classList.remove('hidden'); initGame(); if (typeof Tone !== 'undefined' && !audioInitialized && Tone.context.state !== 'running') { try { await Tone.start(); audioInitialized = true; console.log('Audio context started successfully.'); if (musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music started.'); } } catch (e) { console.error("Error starting audio context:", e); } } else if (audioInitialized && musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music started (context was already running).'); } } });
        function stopMusic() { if (musicLoop && Tone.Transport.state === 'started') { musicLoop.stop(0); Tone.Transport.stop(); Tone.Transport.cancel(); musicStep = 0; console.log('Background music stopped.'); } }
        function goBackToSelect() { stopMusic(); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); gameAreaContainer.classList.add('hidden'); characterSelectContainer.classList.remove('hidden'); characterCards.forEach(c => c.classList.remove('selected')); startGameBtn.disabled = true; selectedCharacterInfo.textContent = 'Select a character to begin!'; selectedCharacter = null; restartBtn.classList.add('hidden'); gameOverMessage.classList.add('hidden'); }
        backToSelectBtn.addEventListener('click', goBackToSelect);
        restartBtn.addEventListener('click', () => { stopMusic(); initGame(); if (audioInitialized && musicLoop && Tone.Transport.state !== 'started') { Tone.Transport.start(); musicLoop.start(0); console.log('Background music restarted.'); } });

        // --- Game Initialization ---
        function initGame() {
             isGameOver = false; score = 0; obstacles = []; collectibles = []; powerups = []; particles = []; platforms = []; projectiles = []; keys = {};
             currentObstacleSpeed = BASE_OBSTACLE_SPEED; currentSpawnIntervalFrames = BASE_SPAWN_INTERVAL_FRAMES;
             timeSinceLastObstacleSpawn = 0; timeSinceLastCollectibleSpawn = 0; timeSinceLastPowerupSpawn = 0; timeSinceLastPlatform = PATTERN_MIN_INTERVAL_FRAMES; // Ensure pattern can spawn early
             timeSinceLastPattern = PATTERN_MIN_INTERVAL_FRAMES; // Reset pattern timer
             backgroundOffset1 = 0; backgroundOffset2 = 0; backgroundOffset3 = 0;
             screenShakeActive = false; screenShakeTimer = 0;
             player = { x: 50, y: GROUND_Y - PLAYER_HEIGHT - 150, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, speed: PLAYER_SPEED, dx: 0, dy: 0, gravity: GRAVITY, jumpStrength: JUMP_STRENGTH, isOnGround: false, wasOnGround: false, jumpsRemaining: MAX_JUMPS, image: null, isPlaceholder: false, isInvincible: false, invincibilityTimer: 0, scoreMultiplier: 1, scoreMultiplierTimer: 0, landedOnPlatform: null, isDashing: false, dashTimer: 0, dashCooldownTimer: 0, dashDirection: 1 };
             scoreDisplay.textContent = `Score: 0`; scoreDisplay.classList.remove('multiplier-active');
             highScoreDisplay.textContent = `High Score: ${highScore}`;
             gameOverMessage.classList.add('hidden'); restartBtn.classList.add('hidden'); backToSelectBtn.disabled = false;
             canvas.style.backgroundPositionX = '0px, 0px, 0px';
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); }
             animationFrameId = null;
             if (selectedCharacter?.imgSrc && selectedCharacter.imgSrc !== 'placeholder') {
                 player.image = new Image();
                 player.image.onload = () => { startGameSystems(); };
                 player.image.onerror = (e) => { console.error("INITGAME: Failed image load:", selectedCharacter.imgSrc, e); player.isPlaceholder = true; startGameSystems(); }
                 player.image.src = selectedCharacter.imgSrc;
             } else {
                 player.isPlaceholder = true;
                 startGameSystems();
             }
        }

        function startGameSystems() {
             window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp);
             window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', handleKeyUp);
             startGameLoop();
        }

        function startGameLoop() {
              if (isGameOver) { return; }
              if (!animationFrameId) { score = 0; animationFrameId = requestAnimationFrame(gameLoop); } else { console.warn("startGameLoop: Loop already running?"); }
        }

        // --- Particle Handling ---
        function spawnParticles(count, x, y, color, speedRange, lifeRange, initialVyBias = 0, initialVxBias = 0) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * speedRange + 0.5; particles.push({ x: x, y: y, vx: Math.cos(angle) * speed + initialVxBias, vy: Math.sin(angle) * speed + initialVyBias, size: Math.random() * 2.5 + 1.5, color: color, life: Math.random() * (lifeRange[1] - lifeRange[0]) + lifeRange[0], initialLife: lifeRange[1] }); } }
        function updateParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += PARTICLE_GRAVITY; p.life--; if (p.life <= 0 || p.size < 0.5) { particles.splice(i, 1); } } }
        function drawParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; ctx.globalAlpha = Math.max(0, p.life / p.initialLife); ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); } ctx.globalAlpha = 1.0; }

        // --- Platform Handling ---
        function spawnPlatform(x, y, width, isMoving = false) { // Helper to spawn single platform
             const platformWidth = width || (Math.random() * (PLATFORM_MAX_WIDTH - PLATFORM_MIN_WIDTH) + PLATFORM_MIN_WIDTH);
             const clampedY = Math.max(PLAYER_HEIGHT * 2, y);
             let pData = { x: x, y: clampedY, width: platformWidth, height: PLATFORM_HEIGHT, type: 'static', vx: 0 };
             if (isMoving) {
                 pData.type = 'moving-x';
                 pData.vx = (Math.random() < 0.5 ? 1 : -1) * PLATFORM_MOVE_SPEED;
                 const moveDist = platformWidth * 0.5 + Math.random() * 50;
                 pData.moveRange = [x - moveDist, x + moveDist]; // Range relative to its own spawn x
                 pData.initialX = x;
             }
             platforms.push(pData);
        }
        function updatePlatforms() { for (let i = platforms.length - 1; i >= 0; i--) { const p = platforms[i]; p.x -= currentObstacleSpeed; if (p.type === 'moving-x') { p.x += p.vx; p.moveRange[0] -= currentObstacleSpeed; p.moveRange[1] -= currentObstacleSpeed; if (p.x <= p.moveRange[0] || p.x + p.width >= p.moveRange[1] + p.width) { p.vx *= -1; p.x = Math.max(p.moveRange[0], Math.min(p.x, p.moveRange[1])); } } if (p.x + p.width < 0) { platforms.splice(i, 1); } } }
        function drawPlatforms() { platforms.forEach(p => { ctx.fillStyle = p.type === 'moving-x' ? tailwind.config.theme.extend.colors['platform-moving'] : tailwind.config.theme.extend.colors.platform; ctx.fillRect(p.x, p.y, p.width, p.height); }); }

        // --- Obstacle Handling ---
        function spawnObstacle(x = canvas.width, typeOverride = null, yPosOverride = null) { // Allow overriding position/type for patterns
            if (isGameOver) return;
            let type = typeOverride;
            let yPos = yPosOverride;
            let emoji, h, w;
            let shootTimer = 0;

            if (!type) { // If type not provided by pattern, choose randomly
                const r = Math.random();
                if (r < 0.4) { type = 'tall'; }
                else if (r < 0.75) { type = 'short'; }
                else { type = 'flying'; }
            }

            // Set properties based on type
            if (type === 'tall') { h = OBSTACLE_HEIGHT_TALL; w = OBSTACLE_WIDTH; yPos = yPosOverride ?? GROUND_Y - h; emoji = EMOJI_OBSTACLE_TALL; }
            else if (type === 'short') { h = OBSTACLE_HEIGHT_SHORT; w = OBSTACLE_WIDTH; yPos = yPosOverride ?? GROUND_Y - h; emoji = EMOJI_OBSTACLE_SHORT; }
            else if (type === 'flying') { h = OBSTACLE_FLYING_SIZE; w = OBSTACLE_FLYING_SIZE; yPos = yPosOverride ?? (canvas.height * 0.5 - Math.random() * (canvas.height * 0.4)); yPos = Math.max(PLAYER_HEIGHT, Math.min(yPos, GROUND_Y - PLAYER_HEIGHT * 2)); emoji = EMOJI_OBSTACLE_FLYING; shootTimer = FLYING_SHOOT_COOLDOWN / 2 + Math.random() * FLYING_SHOOT_COOLDOWN / 2; }
            else { return; } // Unknown type

            obstacles.push({ x: x, y: yPos, width: w, height: h, speed: currentObstacleSpeed, emoji: emoji, type: type, shootTimer: shootTimer });
        }
        function updateObstacles() { for (let i = obstacles.length - 1; i >= 0; i--) { const o = obstacles[i]; o.x -= o.speed; if (o.type === 'flying' && !isGameOver) { o.shootTimer--; if (o.shootTimer <= 0 && o.x < canvas.width && o.x + o.width > 0) { spawnProjectile(o.x + o.width / 2, o.y + o.height); o.shootTimer = FLYING_SHOOT_COOLDOWN; if (projectileShootSynth && audioInitialized) { try { projectileShootSynth.triggerAttackRelease("4n"); } catch(err){ console.error("Shoot sound error:", err); } } } } if (o.x + o.width < 0) { obstacles.splice(i, 1); } } }
        function drawObstacles() { ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; obstacles.forEach(o => { const fs = o.height * 0.9; ctx.font = `${fs}px Arial`; const dX = o.x + o.width / 2; const dY = o.y + o.height / 2; ctx.fillText(o.emoji, dX, dY); }); }

        // --- Projectile Handling ---
        function spawnProjectile(x, y) { projectiles.push({ x: x - PROJECTILE_WIDTH / 2, y: y, width: PROJECTILE_WIDTH, height: PROJECTILE_HEIGHT, vy: PROJECTILE_SPEED }); }
        function updateProjectiles() { for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.y += p.vy; if (p.y > canvas.height) { projectiles.splice(i, 1); } } }
        function drawProjectiles() { ctx.fillStyle = tailwind.config.theme.extend.colors.projectile; projectiles.forEach(p => { ctx.fillRect(p.x, p.y, p.width, p.height); }); }

        // --- Collectible Handling ---
        function spawnCollectible(x = canvas.width + Math.random() * 50, yPos = null) { // Allow position override
             if (isGameOver) return;
             let y = yPos;
             if (y === null) { // Calculate random Y if not provided
                 const p = platforms.find(pf => pf.x > canvas.width / 2 && pf.x < canvas.width);
                 if (p && Math.random() < 0.4) { y = p.y - COLLECTIBLE_SIZE - 2; }
                 else if (Math.random() < 0.4) { y = GROUND_Y - PLAYER_HEIGHT * 1.5 - (Math.random() * 50); }
                 else { y = GROUND_Y - COLLECTIBLE_SIZE - 5 - (Math.random() * 10); }
                 y = Math.max(10, Math.min(y, GROUND_Y - COLLECTIBLE_SIZE - 5));
             }
             collectibles.push({ x: x, y: y, width: COLLECTIBLE_SIZE, height: COLLECTIBLE_SIZE, value: COLLECTIBLE_VALUE, speed: currentObstacleSpeed, emoji: EMOJI_COLLECTIBLE });
         }
        function updateCollectibles() { for (let i = collectibles.length - 1; i >= 0; i--) { const c = collectibles[i]; c.x -= c.speed; if (c.x + c.width < 0) { collectibles.splice(i, 1); } } }
        function drawCollectibles() { const fs = COLLECTIBLE_SIZE * 1.2; ctx.font = `${fs}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; collectibles.forEach(c => { const dX = c.x + c.width / 2; const dY = c.y + c.height / 2; ctx.fillText(c.emoji, dX, dY); }); }

        // --- Powerup Handling ---
         function spawnPowerup(x = canvas.width + Math.random() * 100, yPos = null) { // Allow position override
             if (isGameOver) return;
             let y = yPos;
             if (y === null) {
                 const p = platforms.find(pf => pf.x > canvas.width / 2 && pf.x < canvas.width);
                 if (p && Math.random() < 0.5) { y = p.y - POWERUP_SIZE - 3; } else { y = GROUND_Y - PLAYER_HEIGHT * 1.5 - (Math.random() * 50); }
                 y = Math.max(15, Math.min(y, GROUND_Y - POWERUP_SIZE - 10));
             }
             const type = Math.random() < 0.5 ? 'shield' : 'multiplier'; const emoji = type === 'shield' ? EMOJI_POWERUP_SHIELD : EMOJI_POWERUP_MULTIPLIER;
             powerups.push({ x: x, y: y, width: POWERUP_SIZE, height: POWERUP_SIZE, speed: currentObstacleSpeed * 0.8, emoji: emoji, type: type });
         }
         function updatePowerups() { for (let i = powerups.length - 1; i >= 0; i--) { const p = powerups[i]; p.x -= p.speed; if (p.x + p.width < 0) { powerups.splice(i, 1); } } }
         function drawPowerups() { const fs = POWERUP_SIZE * 1.1; ctx.font = `${fs}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; powerups.forEach(p => { const dX = p.x + p.width / 2; const dY = p.y + p.height / 2; ctx.fillText(p.emoji, dX, dY); }); }

        // --- Pattern Spawning --- (New Section)
        function spawnWallJumpPattern() {
            console.log("Spawning Wall Jump Pattern");
            const startX = canvas.width + 50;
            const wallHeight = OBSTACLE_HEIGHT_TALL;
            const gapWidth = PLAYER_WIDTH * 2.5; // Adjust gap
            const yPos = GROUND_Y - wallHeight;
            // Wall 1
            spawnObstacle(startX, 'tall', yPos);
            // Wall 2 (after gap)
            spawnObstacle(startX + OBSTACLE_WIDTH + gapWidth, 'tall', yPos);
            // Optional: Add collectible in the gap
            spawnCollectible(startX + OBSTACLE_WIDTH + gapWidth / 2, yPos - PLAYER_HEIGHT * 0.8);
             // Reset regular obstacle timer to create space after pattern
            timeSinceLastObstacleSpawn = -BASE_SPAWN_INTERVAL_FRAMES * 0.5; // Negative to delay next spawn
        }

        function spawnPlatformHopPattern() {
             console.log("Spawning Platform Hop Pattern");
             const startX = canvas.width + 30;
             const platWidth = PLATFORM_MIN_WIDTH * 0.8;
             const y1 = GROUND_Y - PLAYER_HEIGHT * 1.2;
             const y2 = GROUND_Y - PLAYER_HEIGHT * 2.2; // Higher platform
             const gap = PLAYER_WIDTH * 1.8;
             // Platform 1
             spawnPlatform(startX, y1, platWidth);
             // Platform 2
             spawnPlatform(startX + platWidth + gap, y2, platWidth);
             // Optional: Collectible on second platform
             spawnCollectible(startX + platWidth + gap + platWidth / 2, y2 - COLLECTIBLE_SIZE * 1.5);
             // Reset regular obstacle timer
             timeSinceLastObstacleSpawn = -BASE_SPAWN_INTERVAL_FRAMES * 0.5;
        }

        // --- Collision Detection (Optimized Check) ---
        function isHorizontallyClose(item, buffer = COLLISION_X_BUFFER) { return item.x < player.x + PLAYER_WIDTH + buffer && item.x + item.width > player.x - buffer; }
        function checkCollision(rect1, rect2) { return ( rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y ); }

        // --- Keyboard Event Handlers ---
        function handleKeyDown(e) { if (isGameOver) return; keys[e.key] = true; if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' ', 'Spacebar', DASH_KEY].includes(e.key)) e.preventDefault(); if ((e.key === 'ArrowUp' || e.key === ' ' || e.key === 'Spacebar')) { if (player.jumpsRemaining > 0 && !player.isDashing) { player.dy = -player.jumpStrength; player.isOnGround = false; player.landedOnPlatform = null; player.jumpsRemaining--; const pColor = player.jumpsRemaining === 0 ? tailwind.config.theme.extend.colors['particle-double-jump'] : tailwind.config.theme.extend.colors['particle-jump']; spawnParticles(player.jumpsRemaining === 0 ? 10 : 5, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT, pColor, 2, [PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE], 1); if (jumpSynth && audioInitialized) { try { jumpSynth.frequency.setValueAtTime(player.jumpsRemaining === 0 ? "D5" : "C5", Tone.now()); jumpSynth.triggerAttackRelease("8n"); } catch(err){ console.error("Jump sound error:", err); } } } } else if (e.key === DASH_KEY) { if (player.dashCooldownTimer <= 0 && !player.isDashing) { player.isDashing = true; player.dashTimer = DASH_DURATION_FRAMES; player.dashCooldownTimer = DASH_COOLDOWN_FRAMES; const horizontalInput = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0); player.dashDirection = horizontalInput !== 0 ? horizontalInput : 1; player.dy = player.dy * 0.5; spawnParticles(15, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, tailwind.config.theme.extend.colors['particle-dash'], 4, [PARTICLE_MIN_LIFE * 0.5, PARTICLE_MAX_LIFE * 0.8], 0, -player.dashDirection * 2); if (dashSynth && audioInitialized) { try { dashSynth.triggerAttackRelease("A4", "16n"); } catch(err){ console.error("Dash sound error:", err); } } } } }
        function handleKeyUp(e) { keys[e.key] = false; }

        // --- Player Update ---
        function updatePlayerState() {
            player.wasOnGround = player.isOnGround; let platformVx = 0;
            if (player.isInvincible) { player.invincibilityTimer--; if (player.invincibilityTimer <= 0) { player.isInvincible = false; } }
            if (player.scoreMultiplierTimer > 0) { player.scoreMultiplierTimer--; if (player.scoreMultiplierTimer <= 0) { player.scoreMultiplier = 1; scoreDisplay.classList.remove('multiplier-active'); } else { scoreDisplay.classList.add('multiplier-active'); } }
            if (player.dashCooldownTimer > 0) { player.dashCooldownTimer--; }
            if (player.isDashing) { player.dashTimer--; player.x += player.dashDirection * PLAYER_SPEED * DASH_SPEED_MULTIPLIER; if (player.dashTimer <= 0) { player.isDashing = false; } player.dx = 0; } else { player.dx = 0; if (keys['ArrowLeft']) player.dx = -player.speed; if (keys['ArrowRight']) player.dx = player.speed; player.x += player.dx; }
            if (player.landedOnPlatform?.type === 'moving-x') { platformVx = player.landedOnPlatform.vx; if (!player.isDashing) { player.x += platformVx; } }
            if (player.x < 0) player.x = 0; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            player.dy += player.gravity; let potentialY = player.y + player.dy; let landedOnSomething = false; let landingSurfaceY = GROUND_Y; let currentPlatform = null;
            if (player.dy >= 0 && !player.isDashing) { for (const platform of platforms) { if (isHorizontallyClose(platform)) { if (player.x + PLAYER_WIDTH > platform.x && player.x < platform.x + platform.width) { if (player.y + PLAYER_HEIGHT <= platform.y + 1 && potentialY + PLAYER_HEIGHT >= platform.y) { potentialY = platform.y - PLAYER_HEIGHT; player.dy = 0; landedOnSomething = true; landingSurfaceY = platform.y; currentPlatform = platform; break; } } } } if (!landedOnSomething && potentialY + PLAYER_HEIGHT >= GROUND_Y) { potentialY = GROUND_Y - PLAYER_HEIGHT; player.dy = 0; landedOnSomething = true; landingSurfaceY = GROUND_Y; currentPlatform = null; } }
            player.y = potentialY; player.isOnGround = landedOnSomething; player.landedOnPlatform = landedOnSomething ? currentPlatform : null;
            if (player.isOnGround) { player.jumpsRemaining = MAX_JUMPS; if (!player.wasOnGround) { spawnParticles(4, player.x + PLAYER_WIDTH / 2, landingSurfaceY, tailwind.config.theme.extend.colors['particle-jump'], 1.5, [PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE * 0.8], -0.5); } }
            if (player.y < 0) { player.y = 0; player.dy = 0; }
            // --- Hazard Check ---
            if (player.y + PLAYER_HEIGHT > GROUND_Y + LAVA_HEIGHT / 2) { // Check if player bottom edge is in lava zone
                 handleGameOver();
            }
        }

        // --- Drawing Functions ---
        function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }
        function drawEnvironment() {
            // Draw Ground
            ctx.fillStyle = tailwind.config.theme.extend.colors.ground;
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
            // Draw Lava below ground
            ctx.fillStyle = tailwind.config.theme.extend.colors.lava;
            ctx.fillRect(0, GROUND_Y + PLATFORM_HEIGHT / 2, canvas.width, canvas.height - (GROUND_Y + PLATFORM_HEIGHT / 2)); // Draw below ground
        }
        function drawPlayer() { const isInvulnerable = player.isInvincible || (player.isDashing && DASH_INVINCIBILITY); if (isInvulnerable) { const alpha = 0.6 + Math.sin(Date.now() / 150) * 0.2; ctx.globalAlpha = Math.max(0.4, alpha); } if (player.image && !player.isPlaceholder && player.image.complete) { ctx.drawImage(player.image, player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT); } else { ctx.fillStyle = tailwind.config.theme.extend.colors['placeholder-bg']; ctx.fillRect(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT); ctx.fillStyle = tailwind.config.theme.extend.colors['placeholder-text']; ctx.font = '12px Inter'; ctx.textAlign = 'center'; const placeholderName = selectedCharacter?.name?.split(' ')[0] || '?'; ctx.fillText(placeholderName, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2 + 5); } ctx.globalAlpha = 1.0; }
        function drawScore() { scoreDisplay.textContent = `Score: ${score}`; }

        // --- Game Over Handling ---
        function handleGameOver() { if(isGameOver) return; isGameOver = true; stopMusic(); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Game Over! Final Score:", score); screenShakeActive = true; screenShakeTimer = SCREEN_SHAKE_DURATION; spawnParticles(25, player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, tailwind.config.theme.extend.colors['particle-gameover'], 4, [PARTICLE_MIN_LIFE * 1.5, PARTICLE_MAX_LIFE * 1.5]); if (gameOverSynth && audioInitialized) { try { gameOverSynth.triggerAttackRelease("C3", "2n"); } catch(err){ console.error("Game over sound error:", err); } } let gameOverText = `Game Over!\nScore: ${score}`; if (score > highScore) { console.log(`New high score: ${score} (previous: ${highScore})`); highScore = score; try { localStorage.setItem(STORAGE_KEY, highScore); highScoreDisplay.textContent = `High Score: ${highScore}`; gameOverText += "\n(New High Score!)"; } catch (e) { console.error("Could not save high score to localStorage:", e); } } gameOverMessage.textContent = gameOverText; gameOverMessage.classList.remove('hidden'); restartBtn.classList.remove('hidden'); backToSelectBtn.disabled = true; window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); }

        // --- Game Loop ---
        function gameLoop() {
             if (isGameOver) { return; }

             // Apply Screen Shake Pre-Draw
             let shakeOffsetX = 0, shakeOffsetY = 0; if (screenShakeActive && screenShakeTimer > 0) { const magnitude = SCREEN_SHAKE_MAGNITUDE * (screenShakeTimer / SCREEN_SHAKE_DURATION); shakeOffsetX = (Math.random() - 0.5) * magnitude * 2; shakeOffsetY = (Math.random() - 0.5) * magnitude * 2; ctx.save(); ctx.translate(shakeOffsetX, shakeOffsetY); screenShakeTimer--; if (screenShakeTimer <= 0) screenShakeActive = false; }

             // Scroll Background Layers
             backgroundOffset1 += currentObstacleSpeed * 0.05; backgroundOffset2 += currentObstacleSpeed * 0.15; backgroundOffset3 += currentObstacleSpeed * 0.3;
             canvas.style.backgroundPositionX = `${-backgroundOffset3}px, ${-backgroundOffset2}px, ${-backgroundOffset1}px`;

             clearCanvas();

             // Update Difficulty
             currentObstacleSpeed = Math.min(MAX_OBSTACLE_SPEED, BASE_OBSTACLE_SPEED + Math.floor(score / SCORE_SPEED_INCREASE_THRESHOLD) * 0.25); currentSpawnIntervalFrames = Math.max(MIN_SPAWN_INTERVAL_FRAMES, BASE_SPAWN_INTERVAL_FRAMES - Math.floor(score / SCORE_INTERVAL_DECREASE_THRESHOLD) * 10);

             // Update Game Elements
             updatePlayerState(); updateObstacles(); updateCollectibles(); updatePowerups(); updateParticles(); updatePlatforms(); updateProjectiles();

             // Check Spawning (Includes Patterns)
             timeSinceLastObstacleSpawn++; timeSinceLastPlatform++; timeSinceLastPattern++;
             let didSpawnPattern = false;
             if (timeSinceLastPattern >= PATTERN_MIN_INTERVAL_FRAMES && Math.random() < PATTERN_SPAWN_CHANCE) {
                 // Try to spawn a pattern
                 const patternChoice = Math.random();
                 if (patternChoice < 0.5) {
                     spawnWallJumpPattern();
                 } else {
                     spawnPlatformHopPattern();
                 }
                 timeSinceLastPattern = 0; // Reset pattern timer
                 timeSinceLastObstacleSpawn = -BASE_SPAWN_INTERVAL_FRAMES; // Add extra delay after pattern
                 didSpawnPattern = true;
             }
             // Regular Spawning if no pattern spawned this frame
             if (!didSpawnPattern && timeSinceLastObstacleSpawn >= currentSpawnIntervalFrames) {
                 if (timeSinceLastPlatform > currentSpawnIntervalFrames * 4 && Math.random() < PLATFORM_SPAWN_CHANCE) { spawnPlatformGroup(); } else { spawnObstacle(); }
                 timeSinceLastObstacleSpawn = 0;
             }
             timeSinceLastCollectibleSpawn++; if (timeSinceLastCollectibleSpawn >= COLLECTIBLE_SPAWN_INTERVAL_FRAMES) { spawnCollectible(); timeSinceLastCollectibleSpawn = 0; }
             timeSinceLastPowerupSpawn++; if (timeSinceLastPowerupSpawn >= POWERUP_SPAWN_INTERVAL_FRAMES) { spawnPowerup(); timeSinceLastPowerupSpawn = 0; }

             // Check Collisions
             const isPlayerVulnerable = !player.isInvincible && !(player.isDashing && DASH_INVINCIBILITY);
             if (isPlayerVulnerable) {
                 for (let obs of obstacles) { if (isHorizontallyClose(obs) && checkCollision(player, obs)) { handleGameOver(); return; } }
                 for (let i = projectiles.length - 1; i >= 0; i--) { const proj = projectiles[i]; if (isHorizontallyClose(proj, 20) && checkCollision(player, proj)) { projectiles.splice(i, 1); handleGameOver(); return; } }
             }
             for (let i = collectibles.length - 1; i >= 0; i--) { const coll = collectibles[i]; if (isHorizontallyClose(coll) && checkCollision(player, coll)) { score += coll.value; spawnParticles(8, coll.x + coll.width / 2, coll.y + coll.height / 2, tailwind.config.theme.extend.colors['particle-collect'], 2.5, [PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE]); collectibles.splice(i, 1); if (collectSynth && audioInitialized) { try { collectSynth.triggerAttackRelease("E5", "16n"); } catch(err){ console.error("Collect sound error:", err); } } } }
             for (let i = powerups.length - 1; i >= 0; i--) { const pow = powerups[i]; if (isHorizontallyClose(pow) && checkCollision(player, pow)) { const powerupType = pow.type; powerups.splice(i, 1);
                    if (powerupType === 'shield') { spawnParticles(12, pow.x + pow.width / 2, pow.y + pow.height / 2, tailwind.config.theme.extend.colors['particle-powerup-shield'], 3, [PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE]); player.isInvincible = true; player.invincibilityTimer = POWERUP_SHIELD_DURATION_FRAMES; console.log("Shield Activated!"); if (powerupShieldSynth && audioInitialized) { try { const now = Tone.now(); powerupShieldSynth.triggerAttackRelease("C4", "16n", now); powerupShieldSynth.triggerAttackRelease("E4", "16n", now + 0.1); powerupShieldSynth.triggerAttackRelease("G4", "16n", now + 0.2); } catch (err) { console.error("Powerup sound error:", err); } } }
                    else if (powerupType === 'multiplier') { spawnParticles(12, pow.x + pow.width / 2, pow.y + pow.height / 2, tailwind.config.theme.extend.colors['particle-powerup-multiplier'], 3, [PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE]); player.scoreMultiplier = SCORE_MULTIPLIER_VALUE; player.scoreMultiplierTimer = MULTIPLIER_DURATION_FRAMES; console.log("Score Multiplier Activated!"); scoreDisplay.classList.add('multiplier-active'); if (powerupMultiplierSynth && audioInitialized) { try { const now = Tone.now(); powerupMultiplierSynth.triggerAttackRelease("G4", "16n", now); powerupMultiplierSynth.triggerAttackRelease("C5", "16n", now + 0.1); powerupMultiplierSynth.triggerAttackRelease("E5", "16n", now + 0.2); } catch (err) { console.error("Multiplier sound error:", err); } } } } }

             // Draw Game Elements
             drawEnvironment(); drawPlatforms(); drawObstacles(); drawCollectibles(); drawPowerups(); drawProjectiles(); drawParticles(); drawPlayer();

             // Update and Draw Score
             score += player.scoreMultiplier;
             drawScore();

             // Restore context if screen shake was applied
             if (screenShakeActive && screenShakeTimer >= -1) { ctx.restore(); }

             // Continue Loop
             if (!isGameOver) { animationFrameId = requestAnimationFrame(gameLoop); } else { animationFrameId = null; }
        }

        // Initialize High Score Display on page load
        if (highScoreDisplay) { highScoreDisplay.textContent = `High Score: ${highScore}`; }

    </script>

</body>
</html>
